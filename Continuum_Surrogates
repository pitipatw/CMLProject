using TopOpt, LinearAlgebra, StatsFuns
using Makie, GLMakie


E = 1.0 # Young’s modulus
v = 0.3 # Poisson’s ratio
f = 1.0 # downward force
rmin = 4.0 # filter radius
xmin = 0.0001 # minimum density
problem_size = (160, 40)
x0 = fill(1.0, prod(problem_size)*2) # initial design
p = 4.0 # penalty
compliance_threshold = 0.1 # maximum compliance

problem = PointLoadCantilever(Val{:Linear}, problem_size, (1.0, 1.0), E, v, f)
#problem = HalfMBB(Val{:Linear}, problem_size, (1.0, 1.0), E, v, f)

solver = FEASolver(Direct, problem; xmin=xmin)

cheqfilter = DensityFilter(solver; rmin=rmin)
stress = TopOpt.von_mises_stress_function(solver)
comp = TopOpt.Compliance(solver)

function obj(x)
    E = x[Int32(length(x)/2)+1:end]
    v = x[1:Int32(length(x)/2)]
    # minimize volume
    return sum(cheqfilter(PseudoDensities(v))) / length(x)
end
function constr(x)
    # compliance upper-bound
    E = x[Int32(length(x)/2)+1:end]
    v = x[1:Int32(length(x)/2)]
    return comp(cheqfilter(PseudoDensities(v.*(f2e(E))))) - compliance_threshold
end

constr(x0)
gradient(constr, x0)
gradient(obj, x0)
m = TopOpt.Model(obj)
addvar!(m, zeros(length(x0)), ones(length(x0)))
Nonconvex.add_ineq_constraint!(m, constr)

options = MMAOptions(; maxiter=1000, tol=Tolerance(; kkt=1e-4, x=1e-4, f=1e-4))
TopOpt.setpenalty!(solver, p)
@time r = Nonconvex.optimize(
    m, MMA87(; dualoptimizer=ConjugateGradient()), x0; options=options
)

Amin = r.minimizer[1:Int32(length(r.minimizer)/2)]
Emin = r.minimizer[Int32(length(r.minimizer)/2)+1:end]


@show obj(r.minimizer)
@show constr(r.minimizer)

@show maximum(stress(cheqfilter(PseudoDensities(Amin))))
topology = cheqfilter(PseudoDensities(Amin)).x

fig = visualize(problem; solver.u,topology = Amin,  default_exagg_scale=0.0, scale_range=10.0)
Makie.display(fig)



# end